{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Litex SOC with Real Time Unit","text":"<p>We use the Litex framework to demonstrate how to design Custom Functions to extending an FPGA-based RISC-V core in a way that it can fully support Real Time system requirements.</p> <p></p>"},{"location":"#real-time-extensions-to-litex","title":"Real Time extensions to Litex","text":"<p>A real-time processor core is a specialized microprocessor designed to handle real-time computing tasks where timing constraints are critical. These tasks require the processor to deliver results within a specified time frame, making them essential in systems where timely execution is crucial, such as in automotive control systems, industrial automation, medical devices, and telecommunications.</p> <p>Key characteristics of real-time processor cores include:</p> <ul> <li>Deterministic Performance : Provide guarantees that tasks are completed within expected completion deadline.</li> <li>Prioritized Task Scheduling: Enable Operating System's schheduler to limit long context switch times which reduce available task utilization and minimize viable task switching granularity needed to prioritize them.</li> <li>Low Latency in Interrupt Handling: Minimize the amount of time elapsed from the source event that causes the preemption and the first instruction of the awakened task (known as interrupt latency).</li> <li>Reliable and Robust: Designed to operate reliably without unexpected failures.</li> </ul> <p>Commercial vendors and IP providers offer such features as in-house solutions which are often proprietary and tightly coupled with the vendor\u2019s instruction set architecture (ISA), target hardware family, and associated software stack. Examples of real-time processor cores include ARM Cortex-R series, Infineon AURIX TriCore, Texas Instruments\u2019 C2000 series, and the Intel Atom processors with real-time extensions.</p>"},{"location":"#risc-v-processor-for-real-time-systems","title":"RISC-V processor for Real-Time Systems","text":"<p>RISC-V ecosystem has been offering a modular, free, and open-source ISA and enables developing custom extensions. RISC-V community has been developing an extension to the Privileged specifications with the proposal of the RISC-V Core-Local Interrupt Controller (CLIC) to handle such real-time scenarios.</p>"},{"location":"#vexriscv-core","title":"VexRiscv Core","text":"<p>VexRiscv is a modular RISC-V core of adaptable pipeline depth with a plugin-based implementation. We propose to implement a new plugin to extend VexRiscv to support Real Time constraints to achieve best-in-class interrupt latency and fast context switching against commercial off-the-shelf (COTS) processor vendors, paving the road for RISC-V architectures in time-critical systems. </p> <p>Detailed architecture can be found at Architecture.</p>"},{"location":"Architecture/","title":"Architecture","text":"<p>Scheduling messages on a peripheral bus like Controller Area Network (CAN) is analogous to scheduling tasks by fixed priorities. We therefore take a brief detour into communication inside a SOC for transactions happening with a single processor.</p>"},{"location":"Architecture/#sequence-diagram-for-transactions-inside-a-soc","title":"Sequence Diagram for transactions inside a SOC","text":"<ul> <li>CPU Core initiates a read operation through the Bus Interconnect to the Memory.</li> <li>Memory responds with the requested data back to the CPU Core through the Bus Interconnect.</li> <li>CPU Core sends a command to a Peripheral.</li> <li>Peripheral acknowledges the command back to the CPU Core.</li> <li>Peripheral triggers an interrupt to the Interrupt Controller.</li> <li>Interrupt Controller sends an interrupt signal to the CPU Core.</li> </ul>"},{"location":"Architecture/#modification-to-litex-for-real-time-systems","title":"Modification to Litex for Real Time Systems","text":"<p>We propose to replace the interrupt controller for Vexriscv in Litex with an implementation of the RISC-V CLIC specifciation, which provides the core with key features such as prioritization by level and priority, selective hardware vectoring, and non-nested interrupt optimization (tail-chaining through the <code>xnxti</code> CSR) directly as RISC-V standard extension.</p>"},{"location":"Architecture/#proposed-plan","title":"Proposed Plan","text":"<p>Detailed roadmap for the proposal can be found at Roadmap.</p>"},{"location":"Milestones/","title":"Development Milestones","text":"<p>For full documentation and milestones, see the Project Blog website.</p>"},{"location":"Milestones/#current-status","title":"Current Status","text":"Task/Milestone Completion 1. Hardware Modifications a. CLIC Top-Level Integration to Vexriscv based SOC 100% b. CLIC Memory Map Implementation 100% c. CLIC Register Logic Implementation 100% d. CLIC Interrupt Logic Implementation 100% e. CLIC Vector Table Implementation 100% 2. Baremetal Software Modifications a. Startup code handling to initialize CLIC 100% b. CLIC interrupt configuration 100% c. CLIC interrupt handlers for Peripherals 100% d. CLIC driver development 100% e. CLIC Software Development Kit(SDK) update 100% 3. Linux Software Modifications a. Linux Startup Code handling for CLIC 100% b. Linux kernel configuration for CLIC 0% c. Linux kernel interrupt Controller Driver for CLIC 0% 4. Verification and Testing a. Verify RISC-V CLIC specification compliance with associated test. Targeting compliance of 75% initially. 0% b. Validate Litex system stability after CLIC integration 0% c. Litex Performance Analysis after CLIC integration 0% d. Documentation about CLIC integration and usage 0%"},{"location":"Roadmap/","title":"Roadmap","text":""},{"location":"Roadmap/#clic-support-in-risc-v-ecosystem","title":"CLIC Support in RISC-V Ecosystem","text":"<p>Adding an extension to the RISC-V architecture involves several steps, from defining the specification to implementing and testing the extension. Here's a high-level roadmap for the process:</p> Steps Status Remark Define the Extension Specification Already Implemented Specification by RISC-V Community. Proposal and Review Already Implemented CLIC ratification status ticket Jira. Simulation Support Already Implemented Already supported by RISC-V ACT. Emulator Support Already Implemented Initial patches in QEMU. Hardware Implementation Not Implemented No Vexriscv support. Commercial &amp; Opensource reference. Software Implementation Not Implemented No Vexriscv support. Opensource reference. Compliance and Testing Not Implemented No Vexriscv support. Reference tests. Documentation and Release Not Implemented No Vexriscv support."},{"location":"Roadmap/#clic-support-in-vexriscv","title":"CLIC Support in Vexriscv","text":""},{"location":"Roadmap/#milestone-1---hardware-modifications","title":"Milestone 1 - Hardware Modifications","text":"<p>This milestone focuses on the hardware modifications needed for integrating the CLIC with the Vexriscv core.</p>"},{"location":"Roadmap/#11-top-level-integration-to-litex-soc","title":"1.1 Top-Level Integration to Litex SOC","text":"<ul> <li> Create CLIC module instance in SoC top-level</li> <li> Connect clock and reset signals</li> <li> Define and connect interrupt input signals from peripherals</li> <li> Connect Vexriscv-to-CLIC configuration interface</li> </ul>"},{"location":"Roadmap/#12-memory-map-implementation","title":"1.2 Memory Map Implementation","text":"<ul> <li> Define CLIC memory map (base address and regions)</li> <li> Implement address decoder for CLIC registers</li> <li> Connect to system bus (TileLink/AHB/AXI)</li> <li> Map CLIC vector table in memory</li> </ul>"},{"location":"Roadmap/#13-register-implementation","title":"1.3 Register Implementation","text":"<ul> <li> Implement CLIC control registers</li> <li> Implement per-interrupt configuration registers</li> <li> Implement interrupt pending/enable registers</li> <li> Implement level/priority registers</li> </ul>"},{"location":"Roadmap/#14-interrupt-logic","title":"1.4 Interrupt Logic","text":"<ul> <li> Implement interrupt priority resolution</li> <li> Implement level-based preemption logic</li> <li> Implement selective hardware vectoring</li> <li> Implement interrupt completion logic</li> </ul>"},{"location":"Roadmap/#15-vector-table","title":"1.5 Vector Table","text":"<ul> <li> Implement vector table storage</li> <li> Implement vector table lookup logic</li> <li> Connect vector addresses to Vexriscv core</li> </ul>"},{"location":"Roadmap/#milestone-2---baremetal-software-modifications","title":"Milestone 2 - Baremetal Software Modifications","text":"<p>This milestone addresses the necessary software changes for supporting CLIC on baremetal systems.</p>"},{"location":"Roadmap/#21-startup-handling","title":"2.1 Startup Handling","text":"<ul> <li> Update bootup code</li> <li> Modify linker scripts</li> <li> Create vector table setup functions</li> <li> Update system initialization functions</li> </ul>"},{"location":"Roadmap/#22-configuration","title":"2.2 Configuration","text":"<ul> <li> Define interrupt priority levels</li> <li> Configure interrupt modes (vectored/non-vectored)</li> <li> Setup privilege levels</li> <li> Configure preemption thresholds</li> </ul>"},{"location":"Roadmap/#23-interrupt-handlers","title":"2.3 Interrupt Handlers","text":"<ul> <li> Create default interrupt handler</li> <li> Implement vectored interrupt handlers</li> <li> Setup interrupt entry/exit code</li> <li> Implement interrupt nesting support</li> </ul>"},{"location":"Roadmap/#24-driver-development","title":"2.4 Driver Development","text":"<ul> <li> Create CLIC initialization function</li> <li> Implement interrupt enable/disable functions</li> <li> Implement interrupt priority setting functions</li> <li> Create vector table setup functions</li> </ul>"},{"location":"Roadmap/#25-software-development-kitsdk-update","title":"2.5 Software Development Kit(SDK) update","text":"<ul> <li> Add CLIC support to build system</li> <li> Add CLIC debugging support</li> </ul>"},{"location":"Roadmap/#milestone-3---linux-software-modifications","title":"Milestone 3 - Linux Software Modifications","text":"<p>This milestone focuses on the necessary software changes needed for CLIC in Linux.</p>"},{"location":"Roadmap/#31-linux-startup-code","title":"3.1 Linux Startup Code","text":"<ul> <li> Initialize CLIC interrupts on RISC-V core booting Linux.</li> <li> Ensure proper initialization of interrupt vectors.</li> <li> Update the Litex boot parameters to recognize the new interrupt controller.</li> </ul>"},{"location":"Roadmap/#32-linux-kernel-configuration","title":"3.2 Linux Kernel Configuration","text":"<ul> <li> Update the device tree to include entries for the new interrupt controller.</li> <li> Update kernel configuration options to include support for the new interrupt controller.</li> </ul>"},{"location":"Roadmap/#33-linux-interrupt-controller-driver","title":"3.3 Linux Interrupt Controller Driver","text":"<ul> <li> Write Linux driver to interface with the new interrupt controller.</li> <li> Add support for interrupt prioritization and preemption.</li> <li> Ensure compatibility with existing Linux kernel interrupt handling mechanisms.</li> </ul>"},{"location":"Roadmap/#milestone-4---verification-and-testing","title":"Milestone 4 - Verification and Testing","text":"<p>This milestone involves thorough verification and testing of the CLIC integration.</p>"},{"location":"Roadmap/#41-compliance-testing","title":"4.1 Compliance Testing","text":"<ul> <li> Verify RISC-V CLIC specification compliance</li> <li> Test privilege level handling</li> <li> Verify CSR functionality</li> <li> Check timing requirements</li> </ul>"},{"location":"Roadmap/#42-system-validation","title":"4.2 System Validation","text":"<ul> <li> Validate system stability</li> <li> Test corner cases</li> <li> Verify error handling</li> <li> Validate power modes</li> </ul>"},{"location":"Roadmap/#43-performance-analysis","title":"4.3 Performance Analysis","text":"<ul> <li> Measure interrupt latency</li> <li> Analyze resource utilization</li> <li> Profile interrupt handling</li> <li> Document performance metrics</li> </ul>"}]}