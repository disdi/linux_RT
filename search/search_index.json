{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Litex SOC with Real Time Unit # We use the Litex framework to demonstrate how to design Custom Functions to extending an FPGA-based RISC-V core in a way that it can fully support Real Time system requirements. Real Time extensions to Litex # A real-time processor core is a specialized microprocessor designed to handle real-time computing tasks where timing constraints are critical. These tasks require the processor to deliver results within a specified time frame, making them essential in systems where timely execution is crucial, such as in automotive control systems, industrial automation, medical devices, and telecommunications. Key characteristics of real-time processor cores include: Deterministic Performance : Provide guarantees that tasks are completed within expected completion deadline. Prioritized Task Scheduling : Enable Operating System's schheduler to limit long context switch times which reduce available task utilization and minimize viable task switching granularity needed to prioritize them. Low Latency in Interrupt Handling : Minimize the amount of time elapsed from the source event that causes the preemption and the first instruction of the awakened task (known as interrupt latency). Reliable and Robust : Designed to operate reliably without unexpected failures. Commercial vendors and IP providers offer such features as in-house solutions which are often proprietary and tightly coupled with the vendor\u2019s instruction set architecture (ISA), target hardware family, and associated software stack. Examples of real-time processor cores include ARM Cortex-R series, Infineon AURIX TriCore, Texas Instruments\u2019 C2000 series, and the Intel Atom processors with real-time extensions. RISC-V processor for Real-Time Systems # RISC-V ecosystem has been offering a modular, free, and open-source ISA and enables developing custom extensions. RISC-V community has been developing an extension to the Privileged specifications with the proposal of the RISC-V Core-Local Interrupt Controller (CLIC) to handle such real-time scenarios. VexRiscv Core # VexRiscv is a modular RISC-V core of adaptable pipeline depth with a plugin-based implementation. We propose to implement a new plugin to extend VexRiscv to support Real Time constraints to achieve best-in-class interrupt latency and fast context switching against commercial off-the-shelf (COTS) processor vendors, paving the road for RISC-V architectures in time-critical systems. Detailed architecture can be found at Architecture .","title":"Litex SOC with Real Time Unit"},{"location":"#litex-soc-with-real-time-unit","text":"We use the Litex framework to demonstrate how to design Custom Functions to extending an FPGA-based RISC-V core in a way that it can fully support Real Time system requirements.","title":"Litex SOC with Real Time Unit"},{"location":"#real-time-extensions-to-litex","text":"A real-time processor core is a specialized microprocessor designed to handle real-time computing tasks where timing constraints are critical. These tasks require the processor to deliver results within a specified time frame, making them essential in systems where timely execution is crucial, such as in automotive control systems, industrial automation, medical devices, and telecommunications. Key characteristics of real-time processor cores include: Deterministic Performance : Provide guarantees that tasks are completed within expected completion deadline. Prioritized Task Scheduling : Enable Operating System's schheduler to limit long context switch times which reduce available task utilization and minimize viable task switching granularity needed to prioritize them. Low Latency in Interrupt Handling : Minimize the amount of time elapsed from the source event that causes the preemption and the first instruction of the awakened task (known as interrupt latency). Reliable and Robust : Designed to operate reliably without unexpected failures. Commercial vendors and IP providers offer such features as in-house solutions which are often proprietary and tightly coupled with the vendor\u2019s instruction set architecture (ISA), target hardware family, and associated software stack. Examples of real-time processor cores include ARM Cortex-R series, Infineon AURIX TriCore, Texas Instruments\u2019 C2000 series, and the Intel Atom processors with real-time extensions.","title":"Real Time extensions to Litex"},{"location":"#risc-v-processor-for-real-time-systems","text":"RISC-V ecosystem has been offering a modular, free, and open-source ISA and enables developing custom extensions. RISC-V community has been developing an extension to the Privileged specifications with the proposal of the RISC-V Core-Local Interrupt Controller (CLIC) to handle such real-time scenarios.","title":"RISC-V processor for Real-Time Systems"},{"location":"#vexriscv-core","text":"VexRiscv is a modular RISC-V core of adaptable pipeline depth with a plugin-based implementation. We propose to implement a new plugin to extend VexRiscv to support Real Time constraints to achieve best-in-class interrupt latency and fast context switching against commercial off-the-shelf (COTS) processor vendors, paving the road for RISC-V architectures in time-critical systems. Detailed architecture can be found at Architecture .","title":"VexRiscv Core"},{"location":"Architecture/","text":"Architecture # Scheduling messages on a peripheral bus like Controller Area Network (CAN) is analogous to scheduling tasks by fixed priorities. We therefore take a brief detour into communication inside a SOC for transactions happening with a single processor. Sequence Diagram for transactions inside a SOC # CPU Core initiates a read operation through the Bus Interconnect to the Memory. Memory responds with the requested data back to the CPU Core through the Bus Interconnect. CPU Core sends a command to a Peripheral. Peripheral acknowledges the command back to the CPU Core. Peripheral triggers an interrupt to the Interrupt Controller. Interrupt Controller sends an interrupt signal to the CPU Core. Modification to Litex for Real Time Systems # We propose to replace the interrupt controller for Vexriscv in Litex with an implementation of the RISC-V CLIC specifciation, which provides the core with key features such as prioritization by level and priority, selective hardware vectoring, and non-nested interrupt optimization (tail-chaining through the xnxti CSR) directly as RISC-V standard extension. Proposed Plan # Detailed roadmap for the proposal can be found at Roadmap .","title":"Architecture"},{"location":"Architecture/#architecture","text":"Scheduling messages on a peripheral bus like Controller Area Network (CAN) is analogous to scheduling tasks by fixed priorities. We therefore take a brief detour into communication inside a SOC for transactions happening with a single processor.","title":"Architecture"},{"location":"Architecture/#sequence-diagram-for-transactions-inside-a-soc","text":"CPU Core initiates a read operation through the Bus Interconnect to the Memory. Memory responds with the requested data back to the CPU Core through the Bus Interconnect. CPU Core sends a command to a Peripheral. Peripheral acknowledges the command back to the CPU Core. Peripheral triggers an interrupt to the Interrupt Controller. Interrupt Controller sends an interrupt signal to the CPU Core.","title":"Sequence Diagram for transactions inside a SOC"},{"location":"Architecture/#modification-to-litex-for-real-time-systems","text":"We propose to replace the interrupt controller for Vexriscv in Litex with an implementation of the RISC-V CLIC specifciation, which provides the core with key features such as prioritization by level and priority, selective hardware vectoring, and non-nested interrupt optimization (tail-chaining through the xnxti CSR) directly as RISC-V standard extension.","title":"Modification to Litex for Real Time Systems"},{"location":"Architecture/#proposed-plan","text":"Detailed roadmap for the proposal can be found at Roadmap .","title":"Proposed Plan"},{"location":"Milestones/","text":"Development Milestones # For full documentation and milestones, see the Project Blog website. Current Status # Task/Milestone Completion 1. Hardware Modifications a. CLIC Top-Level Integration to Vexriscv based SOC 100% b. CLIC Memory Map Implementation 100% c. CLIC Register Logic Implementation 100% d. CLIC Interrupt Logic Implementation 100% e. CLIC Vector Table Implementation 100% 2. Baremetal Software Modifications a. Startup code handling to initialize CLIC 100% b. CLIC interrupt configuration 100% c. CLIC interrupt handlers for Peripherals 100% d. CLIC driver development 100% e. CLIC Software Development Kit(SDK) update 100% 3. Linux Software Modifications a. Linux Startup Code handling for CLIC 100% b. Linux kernel configuration for CLIC 0% c. Linux kernel interrupt Controller Driver for CLIC 0% 4. Verification and Testing a. Verify RISC-V CLIC specification compliance with associated test. Targeting compliance of 75% initially. 0% b. Validate Litex system stability after CLIC integration 0% c. Litex Performance Analysis after CLIC integration 0% d. Documentation about CLIC integration and usage 0%","title":"Development Milestones"},{"location":"Milestones/#development-milestones","text":"For full documentation and milestones, see the Project Blog website.","title":"Development Milestones"},{"location":"Milestones/#current-status","text":"Task/Milestone Completion 1. Hardware Modifications a. CLIC Top-Level Integration to Vexriscv based SOC 100% b. CLIC Memory Map Implementation 100% c. CLIC Register Logic Implementation 100% d. CLIC Interrupt Logic Implementation 100% e. CLIC Vector Table Implementation 100% 2. Baremetal Software Modifications a. Startup code handling to initialize CLIC 100% b. CLIC interrupt configuration 100% c. CLIC interrupt handlers for Peripherals 100% d. CLIC driver development 100% e. CLIC Software Development Kit(SDK) update 100% 3. Linux Software Modifications a. Linux Startup Code handling for CLIC 100% b. Linux kernel configuration for CLIC 0% c. Linux kernel interrupt Controller Driver for CLIC 0% 4. Verification and Testing a. Verify RISC-V CLIC specification compliance with associated test. Targeting compliance of 75% initially. 0% b. Validate Litex system stability after CLIC integration 0% c. Litex Performance Analysis after CLIC integration 0% d. Documentation about CLIC integration and usage 0%","title":"Current Status"},{"location":"Roadmap/","text":"Roadmap # CLIC Support in RISC-V Ecosystem # Adding an extension to the RISC-V architecture involves several steps, from defining the specification to implementing and testing the extension. Here's a high-level roadmap for the process: Steps Status Remark Define the Extension Specification Already Implemented Specification by RISC-V Community. Proposal and Review Already Implemented CLIC ratification status ticket Jira . Simulation Support Already Implemented Already supported by RISC-V ACT . Emulator Support Already Implemented Initial patches in QEMU . Hardware Implementation Not Implemented No Vexriscv support. Commercial & Opensource reference. Software Implementation Not Implemented No Vexriscv support. Opensource reference. Compliance and Testing Not Implemented No Vexriscv support. Reference tests . Documentation and Release Not Implemented No Vexriscv support. CLIC Support in Vexriscv # Milestone 1 - Hardware Modifications # This milestone focuses on the hardware modifications needed for integrating the CLIC with the Vexriscv core. 1.1 Top-Level Integration to Litex SOC # Create CLIC module instance in SoC top-level Connect clock and reset signals Define and connect interrupt input signals from peripherals Connect Vexriscv-to-CLIC configuration interface 1.2 Memory Map Implementation # Define CLIC memory map (base address and regions) Implement address decoder for CLIC registers Connect to system bus (TileLink/AHB/AXI) Map CLIC vector table in memory 1.3 Register Implementation # Implement CLIC control registers Implement per-interrupt configuration registers Implement interrupt pending/enable registers Implement level/priority registers 1.4 Interrupt Logic # Implement interrupt priority resolution Implement level-based preemption logic Implement selective hardware vectoring Implement interrupt completion logic 1.5 Vector Table # Implement vector table storage Implement vector table lookup logic Connect vector addresses to Vexriscv core Milestone 2 - Baremetal Software Modifications # This milestone addresses the necessary software changes for supporting CLIC on baremetal systems. 2.1 Startup Handling # Update bootup code Modify linker scripts Create vector table setup functions Update system initialization functions 2.2 Configuration # Define interrupt priority levels Configure interrupt modes (vectored/non-vectored) Setup privilege levels Configure preemption thresholds 2.3 Interrupt Handlers # Create default interrupt handler Implement vectored interrupt handlers Setup interrupt entry/exit code Implement interrupt nesting support 2.4 Driver Development # Create CLIC initialization function Implement interrupt enable/disable functions Implement interrupt priority setting functions Create vector table setup functions 2.5 Software Development Kit(SDK) update # Add CLIC support to build system Add CLIC debugging support Milestone 3 - Linux Software Modifications # This milestone focuses on the necessary software changes needed for CLIC in Linux. 3.1 Linux Startup Code # Initialize CLIC interrupts on RISC-V core booting Linux. Ensure proper initialization of interrupt vectors. Update the Litex boot parameters to recognize the new interrupt controller. 3.2 Linux Kernel Configuration # Update the device tree to include entries for the new interrupt controller. Update kernel configuration options to include support for the new interrupt controller. 3.3 Linux Interrupt Controller Driver # Write Linux driver to interface with the new interrupt controller. Add support for interrupt prioritization and preemption. Ensure compatibility with existing Linux kernel interrupt handling mechanisms. Milestone 4 - Verification and Testing # This milestone involves thorough verification and testing of the CLIC integration. 4.1 Compliance Testing # Verify RISC-V CLIC specification compliance Test privilege level handling Verify CSR functionality Check timing requirements 4.2 System Validation # Validate system stability Test corner cases Verify error handling Validate power modes 4.3 Performance Analysis # Measure interrupt latency Analyze resource utilization Profile interrupt handling Document performance metrics","title":"Roadmap"},{"location":"Roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"Roadmap/#clic-support-in-risc-v-ecosystem","text":"Adding an extension to the RISC-V architecture involves several steps, from defining the specification to implementing and testing the extension. Here's a high-level roadmap for the process: Steps Status Remark Define the Extension Specification Already Implemented Specification by RISC-V Community. Proposal and Review Already Implemented CLIC ratification status ticket Jira . Simulation Support Already Implemented Already supported by RISC-V ACT . Emulator Support Already Implemented Initial patches in QEMU . Hardware Implementation Not Implemented No Vexriscv support. Commercial & Opensource reference. Software Implementation Not Implemented No Vexriscv support. Opensource reference. Compliance and Testing Not Implemented No Vexriscv support. Reference tests . Documentation and Release Not Implemented No Vexriscv support.","title":"CLIC Support in RISC-V Ecosystem"},{"location":"Roadmap/#clic-support-in-vexriscv","text":"","title":"CLIC Support in Vexriscv"},{"location":"Roadmap/#milestone-1---hardware-modifications","text":"This milestone focuses on the hardware modifications needed for integrating the CLIC with the Vexriscv core.","title":"Milestone 1 - Hardware Modifications"},{"location":"Roadmap/#11-top-level-integration-to-litex-soc","text":"Create CLIC module instance in SoC top-level Connect clock and reset signals Define and connect interrupt input signals from peripherals Connect Vexriscv-to-CLIC configuration interface","title":"1.1 Top-Level Integration to Litex SOC"},{"location":"Roadmap/#12-memory-map-implementation","text":"Define CLIC memory map (base address and regions) Implement address decoder for CLIC registers Connect to system bus (TileLink/AHB/AXI) Map CLIC vector table in memory","title":"1.2 Memory Map Implementation"},{"location":"Roadmap/#13-register-implementation","text":"Implement CLIC control registers Implement per-interrupt configuration registers Implement interrupt pending/enable registers Implement level/priority registers","title":"1.3 Register Implementation"},{"location":"Roadmap/#14-interrupt-logic","text":"Implement interrupt priority resolution Implement level-based preemption logic Implement selective hardware vectoring Implement interrupt completion logic","title":"1.4 Interrupt Logic"},{"location":"Roadmap/#15-vector-table","text":"Implement vector table storage Implement vector table lookup logic Connect vector addresses to Vexriscv core","title":"1.5 Vector Table"},{"location":"Roadmap/#milestone-2---baremetal-software-modifications","text":"This milestone addresses the necessary software changes for supporting CLIC on baremetal systems.","title":"Milestone 2 - Baremetal Software Modifications"},{"location":"Roadmap/#21-startup-handling","text":"Update bootup code Modify linker scripts Create vector table setup functions Update system initialization functions","title":"2.1 Startup Handling"},{"location":"Roadmap/#22-configuration","text":"Define interrupt priority levels Configure interrupt modes (vectored/non-vectored) Setup privilege levels Configure preemption thresholds","title":"2.2 Configuration"},{"location":"Roadmap/#23-interrupt-handlers","text":"Create default interrupt handler Implement vectored interrupt handlers Setup interrupt entry/exit code Implement interrupt nesting support","title":"2.3 Interrupt Handlers"},{"location":"Roadmap/#24-driver-development","text":"Create CLIC initialization function Implement interrupt enable/disable functions Implement interrupt priority setting functions Create vector table setup functions","title":"2.4 Driver Development"},{"location":"Roadmap/#25-software-development-kitsdk-update","text":"Add CLIC support to build system Add CLIC debugging support","title":"2.5 Software Development Kit(SDK) update"},{"location":"Roadmap/#milestone-3---linux-software-modifications","text":"This milestone focuses on the necessary software changes needed for CLIC in Linux.","title":"Milestone 3 - Linux Software Modifications"},{"location":"Roadmap/#31-linux-startup-code","text":"Initialize CLIC interrupts on RISC-V core booting Linux. Ensure proper initialization of interrupt vectors. Update the Litex boot parameters to recognize the new interrupt controller.","title":"3.1 Linux Startup Code"},{"location":"Roadmap/#32-linux-kernel-configuration","text":"Update the device tree to include entries for the new interrupt controller. Update kernel configuration options to include support for the new interrupt controller.","title":"3.2 Linux Kernel Configuration"},{"location":"Roadmap/#33-linux-interrupt-controller-driver","text":"Write Linux driver to interface with the new interrupt controller. Add support for interrupt prioritization and preemption. Ensure compatibility with existing Linux kernel interrupt handling mechanisms.","title":"3.3 Linux Interrupt Controller Driver"},{"location":"Roadmap/#milestone-4---verification-and-testing","text":"This milestone involves thorough verification and testing of the CLIC integration.","title":"Milestone 4 - Verification and Testing"},{"location":"Roadmap/#41-compliance-testing","text":"Verify RISC-V CLIC specification compliance Test privilege level handling Verify CSR functionality Check timing requirements","title":"4.1 Compliance Testing"},{"location":"Roadmap/#42-system-validation","text":"Validate system stability Test corner cases Verify error handling Validate power modes","title":"4.2 System Validation"},{"location":"Roadmap/#43-performance-analysis","text":"Measure interrupt latency Analyze resource utilization Profile interrupt handling Document performance metrics","title":"4.3 Performance Analysis"}]}